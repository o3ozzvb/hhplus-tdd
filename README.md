# 동시성 제어 방식에 대한 보고서

---

## Concurrency (동시성)
- `동시에 실행되는 것처럼 보이는 것`
- 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로, 멀티 태스킹을 위해 `여러 개의 스레드가 번갈아가면서 실행`되는 성질을 의미

## Parallelism (병렬성)
- `실제로 동시에 실행되는 것`
- 멀티 코어에서 멀티 스레드를 동작시키는 방식으로, `한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행`되는 성질을 의미

## Multi Thread (멀티 스레드)
- 하나의 프로세스 내에서 여러 개의 스레드가 동시에 작업을 수행하는 것
- 멀티 스레드 환경에서는 동시에 실행되는 둘 이상의 스레드가 메모리 공간(힙 영역 등)을 공유하기 때문에 동시성 이슈가 발생한다.

## Thread Safe (스레드 안전성)
- 여러 스레드가 동작하는 환경에서도 문제 없이 동작하는 것
- 동시성 이슈가 일어나지 않는다면 `Thread Safe` 하다고 한다.

## 동시성을 제어하는 방법
### 1) 암시적 Lock (synchronized)
- 가장 간단하게 구현할 수 있는 방법
- `synchronized`로 선언된 블럭은 한 스레드만 접근할 수 있다. 메서드를 수행 중인 스레드가 수행을 마치거나 예외가 발생하여 메서드에서 탈출할 때까지 다른 스레드는 해당 자원에 접근할 수 없다.

### 2) 명시적 Lock
- `synchronized` 키워드 없이 명시적으로 `ReentrantLock`을 사용하는 방법
- Lock 의 범위를 메서드 내부에서 한정하기 어렵거나, 동시에 여러 Lock을 사용하고 싶을 때 사용 (직접적으로 Lock 객체를 생성하여 사용)

### 3) Thread Safe 객체 사용
- `Concurrent` 패키지는 각종 스레드 안전한 컬렉션을 제공. (ex. `ConcurrentHashMap`)

**Concuurent 패키지**
- `Concurrent` 패키지에 존재하는 컬렉션들은 락을 사용할 때 발생하는 성능 저하를 최소한으로 만든다. 
락을 여러 개로 분할하여 사용하는 Lock Striping 기법을 사용하여 동시에 여러 스레드가 하나의 자원에 접근하더라도 동시성 이슈가 발생하지 않도록 도와주는 것.

**ConcuurentHashMap**
- `ConcurrentHashMap`은 내부적으로 여러 개의 락을 가지고 해시값을 이용해 락을 분할하여 사용한다. 
- 분할 락을 사용하여 병렬성과 성능을 모두 잡은 컬렉션.
- 내부적으로 여러 락을 사용하여 일반적인 Map을 사용할 때처럼 구현하면 내부적으로 락을 사용하기 때문에 편리함.

**기타...**</br>
**Immutable Instance (불변 객체)**
- 불변객체는 언제나 **Thread Safe** 하다. 
- 대표적인 예는 `String`
- 불변객체는 Lock을 걸 필요가 없다. 내부적인 상태가 변하지 않아 여러 스레드에서 동시에 참조하더라도 동시성 이슈가 발생하지 않는다.

## 공정성
### 공정한 Lock
- 공정한 Lock을 사용할 경우 경쟁이 발생하였을 때 가장 오래 기다린 `Thread`에게 `lock`을 제공
- `Synchronized`는 공정성을 지원하지 않음. 반면 `ReentrantLock`은 생성자의 인자를 통해 공정/불공정 설정이 가능.
---

## Concurrent 패키지
### **java.util.concurrent**  
Java 5 부터 도입. 동기화가 필요한 상황에서 사용할 수 있는 다양한 유틸리티 클래스 제공
- Locks : 상호 배제를 사용할 수 있는 클래스 제공
- Atomic : 동기화가 되어있는 변수 제공
- Executors : 쓰레드 풀 생성, 쓰레드 생명주기 관리, Task 등록과 실행 등을 간편하게 처리 가능  
  - 개발자가 Thread를 하나하나 관리하기가 어려워 쓰레드를 만들고 관리하는 작업을 Executor 에게 위임
  - `execute(Runnable)`, `submit(Runnable)` : 쓰레드 작업 수행
  - `shutdown()` : 할 일을 마치고 종료
  - `shutdownNow()` : 즉시 종료  
- Queue : thread-safe 한 FIFO 큐 제공
- Synchronizers : 특수한 목적의 동기화를 처리하는 5개의 클래스 제공 (Semaphore, CountDownLatch, CyclicBarrier, Phaser, Exchanger)

### 주요 인터페이스
#### 1. **Executors** : 쓰레드 풀의 구현을 위한 인터페이스. **등록된 작업을 실행하는 책임**만 가짐.
- newFixedThreadPool() : 고정된 쓰레드의 갯수를 갖는 쓰레드 풀 생성.  
`ExecutorService` 인터페이스를 구현한 `ThreadPoolExecutor` 객체가 생성됨.

#### 2. **ExecutorService** : `Executor` 인터페이스를 상속받은 인터페이스. **작업 등록**을 위한 인터페이스
- shutdonw() : 라이프사이클을 관리하기 위한 메서드
- submit() : 내부에서 해당 작업을 스케줄링하면서 적절하게 일을 처리함.

> ### 쓰레드 풀을 구현해야 하는 이유
> 1. 소규모 많은 요청이 들어올 경우 쓰레드 생성 및 종료에 따른 오버헤드가 발생한다.
> 2. 생성되는 쓰레드 개수에 제한이 없어 OutOfMemoryError가 발생할 수 있다.
> 3. 많은 수의 쓰레드가 실행될 경우, 쓰레드 스케줄링에 따른 오버헤드가 발생한다.



